import React, { useState, useRef, useEffect, useCallback } from 'react';
import classNames from 'classnames';
import { ConnectedOverlay } from 'rdk';
import { motion } from 'framer-motion';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".Tooltip-module_tooltip__g7YQo {\n  background: var(--color-layer-transparent);\n  border-radius: 5px;\n  color: var(--color-on-background);\n  pointer-events: none;\n  padding: 7px;\n  white-space: nowrap;\n  text-align: center;\n  will-change: transform, opacity; }\n";
var css = {"tooltip":"Tooltip-module_tooltip__g7YQo"};
styleInject(css_248z);

const tooltips = [];
const Tooltip = (_a) => {
    var { className, children, content, disabled = false, enterDelay = 0, leaveDelay = 200, placement = 'top', trigger = 'hover', visible = false, followCursor = false } = _a, rest = __rest(_a, ["className", "children", "content", "disabled", "enterDelay", "leaveDelay", "placement", "trigger", "visible", "followCursor"]);
    const [internalVisible, setInternalVisible] = useState(visible);
    const timeout = useRef();
    const mounted = useRef();
    const ref = useRef(setInternalVisible);
    useEffect(() => {
        // componentDidUpdateLogic style logic
        if (!mounted.current) {
            mounted.current = true;
        }
        else {
            setInternalVisible(visible);
        }
        return () => {
            clearTimeout(timeout.current);
            deactivate();
        };
    }, [visible]);
    const deactivateAll = useCallback(() => tooltips.forEach((r, i) => {
        r(false);
        tooltips.splice(i, 1);
    }), []);
    const deactivate = useCallback(() => {
        const idx = tooltips.indexOf(ref.current);
        if (idx > -1) {
            setInternalVisible(false);
            tooltips.splice(idx, 1);
        }
    }, []);
    return (React.createElement(ConnectedOverlay, Object.assign({}, rest, { placement: placement, trigger: trigger, followCursor: followCursor, open: internalVisible, content: () => {
            const contentChildren = typeof content === 'function' ? content() : content;
            if (!contentChildren) {
                return null;
            }
            return (React.createElement(motion.div, { className: classNames(css.tooltip, className), initial: { opacity: 0, scale: 0.3 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.3 } }, contentChildren));
        }, onActivate: () => {
            if (!internalVisible) {
                deactivateAll();
                clearTimeout(timeout.current);
                timeout.current = setTimeout(() => {
                    if (!disabled) {
                        setInternalVisible(true);
                        tooltips.push(ref.current);
                    }
                }, enterDelay);
            }
        }, onDeactivate: () => {
            clearTimeout(timeout.current);
            timeout.current = setTimeout(() => deactivate(), leaveDelay);
        } }), children));
};

export { Tooltip };
