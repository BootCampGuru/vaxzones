import React, { useLayoutEffect, createContext, forwardRef, useRef, useImperativeHandle, useCallback, useState, Fragment, useEffect, useMemo, useContext } from 'react';
import ScrollLock from 'react-scrolllock';
import { AnimatePresence, motion } from 'framer-motion';
import { createPortal } from 'react-dom';
import classNames from 'classnames';
import PopperJS from 'popper.js';

const useExitListener = (ref, options) => {
    useLayoutEffect(() => {
        const handleClick = event => {
            const el = ref.current;
            if (!(el === null || el === void 0 ? void 0 : el.contains(event.target)) && event.which !== 3) {
                options === null || options === void 0 ? void 0 : options.onClickOutside(event);
            }
        };
        const handleKey = event => {
            if (event.keyCode === 27) {
                options === null || options === void 0 ? void 0 : options.onEscape(event);
            }
        };
        if (options.onClickOutside) {
            document.addEventListener('mousedown', handleClick);
            document.addEventListener('touchstart', handleClick);
        }
        if (handleKey) {
            document.addEventListener('keydown', handleKey);
        }
        return () => {
            if (options.onClickOutside) {
                document.removeEventListener('mousedown', handleClick);
                document.removeEventListener('touchstart', handleClick);
            }
            if (handleKey) {
                document.removeEventListener('keydown', handleKey);
            }
        };
    }, [ref, options]);
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

const OverlayContext = createContext({
    close: () => undefined
});

const Portal = forwardRef(({ children, element = 'div', onMount = () => undefined, onUnmount = () => undefined }, ref) => {
    const elementRef = useRef(document.createElement(element));
    const mounted = useRef(false);
    useLayoutEffect(() => {
        onMount === null || onMount === void 0 ? void 0 : onMount();
        return () => {
            onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount();
            document.body.removeChild(elementRef.current);
        };
    }, []);
    if (!mounted.current) {
        mounted.current = true;
        document.body.appendChild(elementRef.current);
    }
    const portal = createPortal(children, elementRef.current);
    useImperativeHandle(ref, () => elementRef.current);
    return portal;
});

const usePortal = (props = {}) => {
    const ref = useRef(null);
    const Component = useCallback(({ children }) => {
        return React.createElement(Portal, Object.assign({}, props, { ref: ref }), children);
    }, []);
    return [Component, ref];
};

let id = 0;
const genId = () => ++id;
/**
 * Auto-generate a id.
 * Inspired by: https://github.com/reach/reach-ui/blob/master/packages/auto-id/src/index.ts
 */
const useId = (idFromProps) => {
    const [id] = useState(idFromProps || genId());
    return `ref-${id}`;
};

const portals = [];
const START_INDEX = 990;
const useOverlayPortal = (props = {}) => {
    const id = useId();
    const [portalIndex, setPortalIndex] = useState(null);
    const [overlayIndex, setOverlayIndex] = useState(null);
    const [Portal, ref] = usePortal({
        onMount: () => {
            portals.push(id);
            let pidx = portals.indexOf(id);
            if (pidx === -1) {
                pidx = 0;
            }
            setPortalIndex(pidx);
            setOverlayIndex(START_INDEX + pidx * 2 + 1);
            props.onMount && props.onMount();
        },
        onUnmount: () => {
            props.onUnmount && props.onUnmount();
            portals.splice(portals.indexOf(id), 1);
            setPortalIndex(null);
            setOverlayIndex(null);
        }
    });
    return {
        OverlayPortal: Portal,
        ref,
        portalIndex,
        overlayIndex
    };
};

const OverlayPortal = (_a) => {
    var { render, children } = _a, rest = __rest(_a, ["render", "children"]);
    const { OverlayPortal: Component, overlayIndex, portalIndex } = useOverlayPortal(rest);
    const renderer = children || render;
    return (React.createElement(Component, Object.assign({}, rest), renderer({ overlayIndex, portalIndex, backdropIndex: overlayIndex })));
};

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".Backdrop-module_backdrop__3znpY {\n  position: fixed;\n  background: var(--color-layer-transparent);\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  opacity: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none; }\n";
var css$1 = {"backdrop":"Backdrop-module_backdrop__3znpY"};
styleInject(css);

const Backdrop = ({ portalIndex = 0, zIndex = 998, visible = false, className, onClick = () => undefined }) => (React.createElement(AnimatePresence, null,
    React.createElement(Fragment, null, visible && (React.createElement(motion.div, { className: classNames(css$1.backdrop, className), initial: { opacity: 0 }, animate: { opacity: 0.8 - portalIndex / 10 }, exit: { opacity: 0 }, onClick: onClick, style: { zIndex } })))));

const useGlobalOverlay = (options) => {
    const { hasBackdrop = true, closeOnEscape = true, closeOnBackdropClick = true, backdropClassName, onClose = () => undefined, } = options || {};
    const { OverlayPortal, ref, overlayIndex, portalIndex } = useOverlayPortal();
    const [open, setOpen] = useState(false);
    const onBackdropClick = useCallback(() => {
        if (closeOnBackdropClick) {
            onClose === null || onClose === void 0 ? void 0 : onClose();
        }
    }, [closeOnBackdropClick]);
    useExitListener(ref, {
        onEscape: () => closeOnEscape && (onClose === null || onClose === void 0 ? void 0 : onClose()),
    });
    const Component = useCallback(({ children }) => (React.createElement(OverlayContext.Provider, { value: { close: () => onClose === null || onClose === void 0 ? void 0 : onClose() } },
        React.createElement(AnimatePresence, null, open && (React.createElement(OverlayPortal, { key: `go-${portalIndex}` },
            hasBackdrop && (React.createElement(Backdrop, { zIndex: overlayIndex, portalIndex: portalIndex, visible: open, onClick: onBackdropClick, className: backdropClassName })),
            children(),
            React.createElement(ScrollLock, null)))))), [open, overlayIndex, portalIndex, backdropClassName, onBackdropClick]);
    return {
        overlayIndex,
        portalIndex,
        isOpen: open,
        setOpen,
        ref,
        GlobalOverlay: Component
    };
};

const GlobalOverlay = (_a) => {
    var { children, render, open, onClose = () => undefined } = _a, rest = __rest(_a, ["children", "render", "open", "onClose"]);
    const { GlobalOverlay: Component, overlayIndex, portalIndex, setOpen, } = useGlobalOverlay(Object.assign({ onClose }, rest));
    const renderFn = children || render;
    useEffect(() => {
        setOpen(open);
    }, [open]);
    return React.createElement(Component, null, () => renderFn({ overlayIndex, portalIndex }));
};

const OverlayTrigger = forwardRef(({ children, className, elementType = 'span', trigger = ['click'], onActivate, onDeactivate }, ref) => {
    const hasTrigger = useCallback((type) => {
        if (Array.isArray(trigger)) {
            return trigger.includes(type);
        }
        else {
            return type === trigger;
        }
    }, [trigger]);
    const onFocus = useCallback(event => {
        if (hasTrigger('focus')) {
            onActivate({ type: 'focus', nativeEvent: event });
        }
    }, [onActivate, hasTrigger]);
    const onBlur = useCallback(event => {
        if (hasTrigger('focus')) {
            onDeactivate({ type: 'focus', nativeEvent: event });
        }
    }, [onDeactivate, hasTrigger]);
    const onMouseEnter = useCallback(event => {
        if (hasTrigger('hover')) {
            onActivate({ type: 'hover', nativeEvent: event });
        }
    }, [onActivate, hasTrigger]);
    const onMouseLeave = useCallback(event => {
        if (hasTrigger('hover')) {
            onDeactivate({ type: 'hover', nativeEvent: event });
        }
    }, [onDeactivate, hasTrigger]);
    const onClick = useCallback(event => {
        if (hasTrigger('click')) {
            onActivate({ type: 'click', nativeEvent: event });
        }
        // Kill the tooltip on click if its not a click listener
        if (!hasTrigger('click')) {
            onDeactivate({ type: 'hover', nativeEvent: event });
        }
    }, [onActivate, onDeactivate, hasTrigger]);
    const onContextMenu = useCallback(event => {
        if (hasTrigger('contextmenu')) {
            event.preventDefault();
            onActivate({ type: 'contextmenu', nativeEvent: event });
        }
    }, []);
    const tabIndex = hasTrigger('focus') ? -1 : undefined;
    const Component = elementType;
    return (React.createElement(Component, { ref: ref, tabIndex: tabIndex, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onFocus: onFocus, onBlur: onBlur, onClick: onClick, onContextMenu: onContextMenu, className: className }, children));
});

const usePosition = (reference, { followCursor, placement, modifiers } = {}) => {
    const elementRef = useRef(null);
    const popper = useRef(null);
    const mouse = useRef({
        pageX: 0,
        pageY: 0
    });
    // Find the real reference pointer for updating
    const refPointer = reference.current;
    const popperRef = useMemo(() => {
        const refObj = reference;
        if (refObj.current !== undefined) {
            return refObj.current;
        }
        const refElement = reference;
        if (followCursor) {
            return {
                getBoundingClientRect: () => ({
                    top: mouse.current.pageY,
                    right: mouse.current.pageX,
                    bottom: mouse.current.pageY,
                    left: mouse.current.pageX,
                    width: 0,
                    height: 0
                }),
                clientWidth: 0,
                clientHeight: 0
            };
        }
        else if (refElement && !refElement.getBoundingClientRect) {
            const { top, left, width, height } = reference;
            return {
                getBoundingClientRect: () => ({
                    top,
                    left,
                    width,
                    bottom: top - height,
                    right: left - width,
                    height
                }),
                clientWidth: width,
                clientHeight: height
            };
        }
        return refElement;
    }, [followCursor, reference, refPointer, mouse]);
    const onMouseMove = useCallback(({ pageX, pageY }) => {
        var _a;
        mouse.current = { pageX, pageY };
        (_a = popper.current) === null || _a === void 0 ? void 0 : _a.scheduleUpdate();
    }, []);
    useLayoutEffect(() => {
        if (elementRef.current && popperRef) {
            popper.current = new PopperJS(popperRef, elementRef.current, {
                placement: placement || 'top',
                modifiers: modifiers || {},
                onCreate: () => {
                    if (followCursor) {
                        window.addEventListener('mousemove', onMouseMove);
                    }
                }
            });
        }
        return () => {
            var _a;
            if (!elementRef.current) {
                (_a = popper.current) === null || _a === void 0 ? void 0 : _a.destroy();
                if (followCursor) {
                    window.removeEventListener('mousemove', onMouseMove);
                }
            }
        };
    }, [elementRef.current]);
    useLayoutEffect(() => {
        if (popper.current) {
            popper.current.reference = popperRef;
            popper.current.scheduleUpdate();
        }
    }, [popperRef]);
    return [elementRef, popper];
};

var css$2 = ".Position-module_container__2OGTq {\n  pointer-events: none; }\n  .Position-module_container__2OGTq > * {\n    pointer-events: initial; }\n";
var css$3 = {"container":"Position-module_container__2OGTq"};
styleInject(css$2);

const Position = forwardRef((_a, ref) => {
    var { className, style, children, reference } = _a, rest = __rest(_a, ["className", "style", "children", "reference"]);
    const [positionRef, popperRef] = usePosition(reference, rest);
    useImperativeHandle(ref, () => ({
        updatePosition: () => popperRef.current.scheduleUpdate()
    }));
    return (React.createElement("span", { ref: positionRef, className: classNames(className, css$3.container), style: style }, children));
});

const useConnectedOverlay = (triggerRef, options) => {
    const { closeOnBodyClick = true, closeOnEscape = true, elementType, style = {}, className, appendToBody = true, followCursor, modifiers, placement = 'bottom' } = options || {};
    const [open, setOpen] = useState(false);
    const { OverlayPortal, ref, overlayIndex, portalIndex } = useOverlayPortal();
    const [positionRef, innerPopperRef] = usePosition(triggerRef, {
        followCursor,
        modifiers,
        placement
    });
    useExitListener(ref, {
        onClickOutside: event => {
            if (closeOnBodyClick) {
                let ref = null;
                if (triggerRef.current) {
                    ref = triggerRef
                        .current;
                }
                else if (triggerRef.contains !== undefined) {
                    ref = triggerRef;
                }
                if (ref && !ref.contains(event.target)) {
                    setOpen(false);
                }
            }
        },
        onEscape: () => closeOnEscape && setOpen(false)
    });
    const Component = useCallback(({ children }) => (React.createElement(OverlayContext.Provider, { value: { close: () => setOpen(false) } },
        React.createElement(AnimatePresence, null, open && (appendToBody ? (React.createElement(OverlayPortal, { key: `co-${overlayIndex}`, elementType: elementType },
            React.createElement("div", { ref: positionRef, style: Object.assign({ zIndex: overlayIndex }, (style || {})), className: className }, children({ overlayIndex, portalIndex })))) : (React.createElement("div", { key: `co-${overlayIndex}`, ref: positionRef, style: Object.assign({ zIndex: overlayIndex }, (style || {})), className: className }, children({ overlayIndex, portalIndex }))))))), [open, overlayIndex, portalIndex]);
    return {
        overlayIndex: overlayIndex,
        portalIndex: portalIndex,
        isOpen: open,
        setOpen,
        ref,
        popperRef: innerPopperRef,
        ConnectedOverlay: Component
    };
};

const ConnectedOverlay = forwardRef((_a, ref) => {
    var { reference, children, open, content, triggerElement, triggerClassName, trigger = 'click', onActivate, onDeactivate } = _a, rest = __rest(_a, ["reference", "children", "open", "content", "triggerElement", "triggerClassName", "trigger", "onActivate", "onDeactivate"]);
    const mounted = useRef(false);
    const overlayTriggerRef = useRef(null);
    const triggerRef = reference || overlayTriggerRef;
    const { ConnectedOverlay: Component, setOpen, isOpen, popperRef } = useConnectedOverlay(triggerRef, rest);
    useImperativeHandle(ref, () => ({
        updatePosition: () => {
            var _a;
            (_a = popperRef === null || popperRef === void 0 ? void 0 : popperRef.current) === null || _a === void 0 ? void 0 : _a.scheduleUpdate();
        }
    }));
    useEffect(() => {
        setOpen(open);
    }, [open]);
    useEffect(() => {
        if (mounted.current) {
            if (!isOpen) {
                onDeactivate && onDeactivate();
            }
            else {
                onActivate && onActivate();
            }
        }
        else {
            mounted.current = true;
        }
    }, [isOpen]);
    return (React.createElement(Fragment, null,
        children &&
            (trigger ? (React.createElement(OverlayTrigger, { elementType: triggerElement, ref: overlayTriggerRef, className: triggerClassName, trigger: trigger, onActivate: event => {
                    onActivate === null || onActivate === void 0 ? void 0 : onActivate(event);
                }, onDeactivate: event => {
                    onDeactivate === null || onDeactivate === void 0 ? void 0 : onDeactivate(event);
                } }, children)) : (children)),
        React.createElement(Component, null, () => content())));
});

const useOverlay = () => {
    const context = useContext(OverlayContext);
    if (context === undefined) {
        throw new Error('`useOverlay` hook can only be used inside a overlay component.');
    }
    return context;
};

export { Backdrop, ConnectedOverlay, GlobalOverlay, OverlayContext, OverlayPortal, OverlayTrigger, Portal, Position, useConnectedOverlay, useExitListener, useGlobalOverlay, useId, useOverlay, useOverlayPortal, usePortal, usePosition };
